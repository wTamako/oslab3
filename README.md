## 练习1：理解基于FIFO的页面替换算法（思考题）

描述FIFO页面置换算法下，一个页面从被换入到被换出的过程中，会经过代码里哪些函数/宏的处理（或者说，需要调用哪些函数/宏），并用简单的一两句话描述每个函数在过程中做了什么？（为了方便同学们完成练习，所以实际上我们的项目代码和实验指导的还是略有不同，例如我们将FIFO页面置换算法头文件的大部分代码放在了kern/mm/swap_fifo.c文件中，这点请同学们注意）

至少正确指出10个不同的函数分别做了什么？如果少于10个将酌情给分。我们认为只要函数原型不同，就算两个不同的函数。要求指出对执行过程有实际影响,删去后会导致输出结果不同的函数（例如assert）而不是cprintf这样的函数。如果你选择的函数不能完整地体现”从换入到换出“的过程，比如10个函数都是页面换入的时候调用的，或者解释功能的时候只解释了这10个函数在页面换入时的功能，那么也会扣除一定的分数

### 回答：

1. `get_pte(pde_t *pgdir, uintptr_t la, bool create)`: 根据传入的线性地址la和页目录表pgdir获取对应的页表项，并返回该页表项对应的内核虚拟地址。必要时会为各级页表项对应的页表各分配一个页。

2. `swap_in(mm_struct *mm, uintptr_t addr, struct Page **ptr_page)`: 页面换入的核心：为ptr_result分配一个内存页，根据addr获取要交换的页表项，再调用 swapfs_read 函数把相应磁盘页中的内容读取到分配的内存页中来。

3. `page_insert(pde_t *pgdir, struct Page *page, uintptr_t addr, uint32_t perm)`: 此函数将页面插入到地址空间指定的虚拟地址，同时在页表中添加相应的页目录项。

4. `swap_map_swappable(mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in)`: 如果页面已经在页表里，此函数会将页面设置为可交换状态。

5. `_fifo_init_mm(struct mm_struct *mm)`: 初始化内存管理结构体(mm)的sm_priv字段并将它设置为FIFO链表的头结点。

6. `list_init()`: 用于初始化list_entry_t结构的双向链表，这里用于初始化pra_list_head，在页面换入换出这个函数用于做前期准备。

7. `_fifo_map_swappable(struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in)`: 将一个新换入内存的页面加入链表。

8. `assert()`: 是一个宏定义在 <assert.h> 头文件中，用于在程序执行过程中进行断言检查，即确保某个条件为真。如果断言条件为假，即条件不满足，assert() 会触发一个断言错误，并打印出错信息，终止程序的执行。

9. `list_add(list_entry_t *listelm, list_entry_t *elm)`: 将一个新元素加入链表的头部，使它成为最近进入队列的页面。

10. `fifo_swap_out_victim(struct mm_struct *mm, struct Page **ptr_page, int in_tick)`: 选择一个页面以供换出。

11. `list_prev(list_entry_t *listelm)`: 返回链表中当前元素的前一个元素。在FIFO规则下，list_prev可以帮助我们从后向前找可以换出的页面。

12. `list_del(list_entry_t *listelm)`: 从链表中删除一个指定的元素。

13. `le2page(list_entry_t *le, type *member)`: 将链表元素转换为页面结构类型指针，从而能够访问页面上的数据。依照指针获取页面，由于我们pra_list_head存储的是页面的指针，这个可以帮助我们获取对应页面后根据页面状态判断是否换出。

## 练习2：深入理解不同分页模式的工作原理（思考题）

`get_pte()`函数（位于kern/mm/pmm.c）用于在页表中查找或创建页表项，从而实现对指定线性地址对应的物理页的访问和映射操作。这在操作系统中的分页机制下，是实现虚拟内存与物理内存之间映射关系非常重要的内容。

`get_pte()`函数中有两段形式类似的代码， 结合sv32，sv39，sv48的异同，解释这两段代码为什么如此相像。

目前`get_pte()`函数将页表项的查找和页表项的分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？

### 回答：

这两段代码看起来相似，因为它们都在实施同样的过程：寻找（如果不存在则创建）一个页目录或页表项。这是因为在Sv32, Sv39和Sv48的虚拟内存方案中，都引入了多级页表结构来实现虚拟内存和物理内存之间的映射。在多级页表中，首先我们要通过页目录（PDE: Page Directory Entry）去找到页表（PTE: Page Table Entry），然后再通过页表找到真正映射的物理地址。这两级或更多级的查找机制使我们能够更有效地管理和映射内存，特别是对于大内存量的系统。每一级的页表都可以动态增长，只需要为使用的部分分配内存，这样可以提高内存使用效率，降低内存浪费。

第一段代码是在页目录（PDE）中寻找或创建PDE。如果PDE不存在，则创建一个，容纳PTE的页并将其物理地址填充进PDE的项中。将PDE的存在标志位设置为1。第二段代码则是在页表数组中查找或创建页表项（PTE）。如果此页的PTE不存在，则为该PTE所对应的物理页分配一张页。

这两段看起来类似的代码，其真正实质就是多级页表的实现过程，实现了从虚拟地址到物理地址的映射。Sv32, Sv39, Sv48只是页表级数的区别，按32, 39, 48位虚拟地址来划分页目录和页表的层数。

`get_pte()`函数将查找和分配页表项的功能合并在一起，是出于需求考虑。我们在查找页表项时，如果不存在，会需要创建一个新的页表项。所以将这两个功能合并在一个函数中，可以简化调用该函数时的代码。拆分这两个功能优点是代码的逻辑更清晰，函数的职责更单一，使得在将来如果查找和分配的逻辑或需求有所变动时，更容易进行修改和测试。这样做的缺点是可能会增加代码的复杂性，而且，如果这两个操作总是连续执行的，那么分开他们并没有提供任何实际的优势，反而会增加代码的冗余度。

## 练习3：给未被映射的地址映射上物理页（需要编程）

补充完成`do_pgfault`（mm/vmm.c）函数，给未被映射的地址映射上物理页。设置访问权限的时候需要参考页面所在VMA的权限，同时需要注意映射物理页时需要操作内存控制结构所指定的页表，而不是内核的页表。

请在实验报告中简要说明你的设计实现过程。请回答如下问题：

1. 请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。

2. 如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？

3. 数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？

### 回答：

**设计实现过程：**

实现`do_pgfault`函数时，首先查找页表项（pte）。如果页表不存在，创建一个新的页表。如果找到的pte为空，试图在此地址处分配一个新的物理页并加载到新创建的页表条目中。如果pte不为空，在这种情况下，需要将磁盘上的页面数据加载到一个新分配的内存页面中，这是通过调用`swap_in`函数实现的。然后使用`page_insert`函数将新加载的页面的物理地址与其逻辑地址进行映射。为了能够在需要时将页面交换出内存，调用`swap_map_swappable`函数将页面设置为可交换。

**问题回答：**

1. 页目录项（Page Directory Entry）和页表项（Page Table Entry）中的各个组成部分提供了对页面在物理内存和磁盘上的状态的描述。这些状态信息在实现页替换算法时能够被用于决策哪些页面应该留在内存中、哪些页面应该被替换出去，以及是否需要写回到磁盘。

2. 在页访问异常发生时，硬件会立即停止当前任务，并保护现场，将当前的程序计数器、堆栈指针、标志寄存器等重要寄存器的内容保存到堆栈中，以便在解决异常后可以恢复到现场。然后CPU将识别出这个是页访问异常，硬件会跳转到相应的异常处理程序进行处理。在Page Fault异常发生时，操作系统可以通过STVAL寄存器获取引发异常的地址，然后根据页表信息加载页面。而`scause`寄存器则提供了异常类型的信息，使得操作系统可以区分不同的异常类型，并采取不同的处理策略。

3. 数据结构`Page`的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项是有对应关系的。每个`Page`结构体代表了操作系统所管理的一个物理页的信息。页表是由页目录和页表项构成的，他们的任务就是将虚拟地址映射到物理地址。其中，页表项（Page Table Entry，PTE），在有效（PTE_P为1，即Present标志位为1）的情况下指向对应的物理页。我们可以通过页表项找到对应的物理页的基地址，然后这个物理地址在`pages`数组中就存在一个对应的元素，即代表该物理页的`Page`结构体。逆向地，我们也可以通过`Page`结构体中的`pra_vaddr`字段获取该物理页被映射的虚拟地址。

## 练习4：补充完成Clock页替换算法（需要编程）

通过之前的练习，相信大家对FIFO的页面替换算法有了更深入的了解，现在请在我们给出的框架上，填写代码，实现 `Clock` 页替换算法（mm/swap_clock.c）。(提示:要输出`curr_ptr`的值才能通过`make grade`)

请在实验报告中简要说明你的设计实现过程。请回答如下问题：

1. 比较`Clock`页替换算法和`FIFO`算法的不同。

### 回答：

**设计实现过程：**

1. `_clock_init_mm`函数：
   - 首先，使用`list_init`函数初始化`pra_list_head`为空链表。
   - 然后，将`curr_ptr`指向`pra_list_head`，表示当前页面替换位置为链表头。
   - 最后，将`mm`的私有成员指针指向`pra_list_head`，以便后续的页面替换算法操作。

2. `_clock_map_swappable`函数：
   - 首先，通过`page`结构中的`pra_page_link`指针获取页面对应的`entry`指针。
   - 然后，将页面插入到页面链表`pra_list_head`的末尾，使用`list_add`函数实现。
   - 接下来，将页面的`visited`标志置为1，表示该页面已被访问。
   - 最后，输出当前指针`curr_ptr`的值。

3. `_clock_swap_out_victim`函数：
   - 首先，通过`mm`的私有成员指针获取页面链表`pra_list_head`的头指针`head`。
   - 然后，断言`head`不为`NULL`。
   - 接着，遍历页面链表`pra_list_head`，查找最早未被访问的页面。
   - 在遍历过程中，获取当前页面对应的`Page`结构指针。
   - 如果当前页面未被访问，则将该页面从页面链表中删除，将该页面指针赋值给`ptr_page`作为换出页面。
   - 如果当前页面已被访问，则将`visited`标志置为0，表示页面已被重新访问。
   - 最后，更新`curr_ptr`为当前页面的前一个页面，并返回0表示成功换出页面。

**问题回答：**

1. **比较 `Clock` 页替换算法和 `FIFO` 算法的不同：**
   - 在`FIFO`算法中，只需从页面链表的头部取出最早到达的页面作为换出页面，然后将其从链表中删除。
   - 在`Clock`算法中，需要遍历页面链表，查找最早未被访问的页面作为换出页面。如果找到了未被访问的页面，则将其从链表中删除。如果所有页面都已被访问，则将访问标志重新置为0，表示页面已被重新访问。`Clock`算法还维护了一个`visited`标志来记录页面的访问情况，并通过维护一个指针，不断遍历页面链表来找到最早未被访问的页面。而`FIFO`算法则直接从页面链表的头部取出最早的页面。

## 练习5：阅读代码和实现手册，理解页表映射方式相关知识（思考题）

**问题：** 如果我们采用 "一个大页" 的页表映射方式，相比分级页表，有什么好处、优势，有什么坏处、风险？

### 回答：

**好处：**

1. **减少页表的数量：** "一个大页" 的页表映射方式可以通过使用更大的页面来减少页表的数量，从而减少页表的管理开销和内存占用。这可以提高内存管理的效率和性能。

2. **提高 TLB（Translation Lookaside Buffer）的命中率：** 使用大页表可以提高 TLB 的命中率。因为 TLB 是用来缓存最近访问的页表项的，而使用大页表可以减少页表项的数量，从而在 TLB 中存储更多的有效映射，更容易实现高命中率。

3. **减少内存访问延迟：** 使用大页表可以减少内存访问的次数，从而降低内存访问的延迟。因为在使用大页时，单个页面对应的物理内存区域更大，一个页表项就可以映射更多的内存空间，减少了页表项的访问次数。

**坏处：**

1. **内存浪费：** 使用大页会导致更多的内存浪费。因为每个页面都是固定大小的，如果没有充分利用页内内存空间，可能会造成较大的浪费。

2. **内存碎片化：** 使用大页会增加内存碎片化的风险。由于每个大页的大小固定，可能会导致某些小于大页的内存空间无法被充分利用，从而引发内存碎片化问题。

3. **上下文切换开销：** 在使用大页时，如果多个进程或线程共享同一个大页，那么在进行上下文切换时可能会引入额外的开销。因为在切换到新的进程或线程时，需要刷新 TLB 缓存中的页表项。
